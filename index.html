<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image Forensics Tool</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.6.0/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Custom styles for form elements */
        .styled-checkbox:checked {
            background-image: url("data:image/svg+xml,%3csvg viewBox='0 0 16 16' fill='white' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M12.207 4.793a1 1 0 010 1.414l-5 5a1 1 0 01-1.414 0l-2-2a1 1 0 011.414-1.414L6.5 9.086l4.293-4.293a1 1 0 011.414 0z'/%3e%3c/svg%3e");
            background-color: #4f46e5;
            border-color: #4f46e5;
        }
        .styled-radio:checked {
            background-image: url("data:image/svg+xml,%3csvg viewBox='0 0 16 16' fill='white' xmlns='http://www.w3.org/2000/svg'%3e%3ccircle cx='8' cy='8' r='3'/%3e%3c/svg%3e");
            background-color: #4f46e5;
            border-color: #4f46e5;
        }
        .drop-area {
            border: 2px dashed #d1d5db;
            transition: border-color 0.2s, background-color 0.2s;
        }
        .drop-area.drag-over {
            border-color: #6366f1;
            background-color: #f0f1ff;
        }
        .dark .drop-area.drag-over {
            background-color: #2b3142;
        }
        .control-disabled, .control-disabled label, .control-disabled input {
            opacity: 0.5;
            cursor: not-allowed;
        }
        /* Basic styling for rendered markdown content */
        .prose h1, .prose h2, .prose h3 { font-weight: 600; margin-top: 1.2em; margin-bottom: 0.5em; }
        .prose h1 { font-size: 1.875rem; }
        .prose h2 { font-size: 1.5rem; }
        .prose h3 { font-size: 1.25rem; }
        .prose p { margin-bottom: 1em; line-height: 1.6; }
        .prose ul, .prose ol { margin-left: 1.5em; margin-bottom: 1em; }
        .prose li { margin-bottom: 0.5em; }
        .prose a { color: #4f46e5; text-decoration: underline; }
        .prose code { background-color: #e5e7eb; padding: 0.2em 0.4em; border-radius: 3px; font-family: monospace; }
        .dark .prose a { color: #a5b4fc; }
        .dark .prose code { background-color: #374151; }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-100 min-h-screen flex flex-col items-center justify-center p-4 transition-colors">
    
    <button id="darkModeToggle" class="fixed top-4 right-4 p-2 rounded-full bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 transition-colors shadow">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" id="darkModeIcon"></svg>
    </button>
    
    <div class="bg-white dark:bg-gray-800 p-8 rounded-lg shadow-lg max-w-5xl w-full transition-colors">
        <div class="flex justify-between items-center mb-2">
            <h1 class="text-3xl font-bold">Image Forensics Tool</h1>
            <button id="toggleViewBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 dark:bg-gray-700 dark:hover:bg-gray-600 dark:text-gray-200 font-bold py-2 px-4 rounded-full transition-colors text-sm">
                Switch to Batch Mode
            </button>
        </div>

        <div class="border-b border-gray-200 dark:border-gray-700 mb-4">
            <nav class="-mb-px flex space-x-8" id="tabs">
                <button id="analysisTab" class="whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm border-violet-500 text-violet-600">
                    Analysis Tool
                </button>
                <button id="documentationTab" class="whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300 dark:text-gray-400 dark:hover:text-gray-200 dark:hover:border-gray-600">
                    Documentation
                </button>
            </nav>
        </div>

        <div id="analysisContainer">
            <div id="singleFileView">
                <p class="text-center text-gray-600 dark:text-gray-400 mb-6">Use this tool to analyze compression artifacts in a single image.</p>
                <div id="drop-area-single" class="drop-area p-6 rounded-lg text-center mb-6">
                    <label for="fileInput" class="font-semibold mb-2">Drag & Drop or Select a File:</label>
                    <input id="fileInput" type="file" accept="image/*" class="w-full text-sm text-gray-500 dark:text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-violet-50 file:text-violet-700 hover:file:bg-violet-100 dark:file:bg-violet-800 dark:file:text-violet-200 dark:hover:file:bg-violet-700 cursor-pointer transition-colors mt-2">
                </div>
            </div>

            <div id="batchView" class="hidden">
                <p class="text-center text-gray-600 dark:text-gray-400 mb-6">Process multiple images at once. All images will be resized before processing.</p>
                <div id="drop-area-batch" class="drop-area p-6 rounded-lg text-center mb-4">
                    <label for="batchFileInput" class="font-semibold mb-2">Drag & Drop or Select Multiple Images:</label>
                    <input id="batchFileInput" type="file" accept="image/*" multiple class="w-full text-sm text-gray-500 dark:text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-violet-50 file:text-violet-700 hover:file:bg-violet-100 dark:file:bg-violet-800 dark:file:text-violet-200 dark:hover:file:bg-violet-700 cursor-pointer transition-colors mt-2">
                </div>
                <div class="flex justify-center mb-4">
                    <label for="maxSizeInput" class="font-semibold mr-2 self-center">Max Size (longest side):</label>
                    <input type="number" id="maxSizeInput" value="1000" class="bg-gray-200 dark:bg-gray-700 rounded-lg p-2 w-24 text-center">
                </div>
                <div id="fileList" class="text-center text-sm text-gray-500 dark:text-gray-400 mb-4 h-6"></div>
            </div>
            
            <div id="configManager" class="border-t border-gray-200 dark:border-gray-700 pt-4 mt-4 mb-6">
                <h2 class="text-xl font-semibold mb-3 text-center">Configuration Profiles</h2>
                <div id="configList" class="h-24 overflow-y-auto bg-gray-100 dark:bg-gray-700 rounded-md p-2 border border-gray-300 dark:border-gray-600 mb-3">
                    </div>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 items-center">
                    <div class="flex items-center gap-2">
                        <input type="text" id="configNameInput" placeholder="Enter profile name..." class="w-full bg-white dark:bg-gray-800 rounded-md p-2 border border-gray-300 dark:border-gray-600 text-sm">
                        <button id="saveConfigBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md text-sm whitespace-nowrap">Save As</button>
                    </div>
                    <div class="grid grid-cols-2 gap-2">
                        <button id="loadConfigBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-md text-sm">Load Selected</button>
                        <button id="deleteConfigBtn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-md text-sm">Delete Selected</button>
                    </div>
                </div>
                <div class="flex justify-center space-x-4 mt-4">
                    <button id="importConfigBtn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-md text-sm">Import Profiles</button>
                    <button id="exportConfigBtn" class="bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-md text-sm">Export Profiles</button>
                    <input type="file" id="importConfigFileInput" class="hidden" accept=".json">
                </div>
            </div>

            <div id="sharedControls" class="border-t border-b border-gray-200 dark:border-gray-700 py-6 my-6">
                <div class="grid grid-cols-1 md:grid-cols-3 gap-x-6 gap-y-6">
                
                    <div class="space-y-4">
                        <div>
                            <label class="font-semibold mb-2 block">Analysis Mode:</label>
                            <div class="grid grid-cols-2 gap-2">
                                <label class="flex items-center"><input type="radio" name="topLevelAnalysisMode" value="ida" class="w-4 h-4 mr-2 styled-radio" checked> IDA</label>
                                <label class="flex items-center"><input type="radio" name="topLevelAnalysisMode" value="ela" class="w-4 h-4 mr-2 styled-radio"> ELA</label>
                                <label class="flex items-center"><input type="radio" name="topLevelAnalysisMode" value="hybrid" class="w-4 h-4 mr-2 styled-radio"> Hybrid</label>
                                <label class="flex items-center"><input type="radio" name="topLevelAnalysisMode" value="double-exposure" class="w-4 h-4 mr-2 styled-radio"> Double Exposure</label>
                            </div>
                        </div>
                        <div id="mContainer">
                            <label for="mInput" class="font-semibold mb-2 block">Factor (m): <span id="mVal" class="font-normal">4</span></label>
                            <input id="mInput" type="range" min="1" max="5" value="4" class="w-full h-2 bg-gray-200 dark:bg-gray-700 rounded-lg appearance-none cursor-pointer">
                        </div>
                        <div id="idaSpecificControls">
                            <label for="xInput" class="font-semibold mb-2 block">Degradation (x): <span id="xVal" class="font-normal">5</span></label>
                            <input id="xInput" type="range" min="1" max="10" value="5" class="w-full h-2 bg-gray-200 dark:bg-gray-700 rounded-lg appearance-none cursor-pointer">
                        </div>
                    </div>

                    <div class="space-y-4">
                        <div>
                            <label class="font-semibold mb-2 block">Channel:</label>
                            <div class="grid grid-cols-2 gap-y-2 gap-x-4">
                                <label class="flex items-center text-sm"><input type="radio" name="channelMode" value="standard" class="w-4 h-4 mr-2 styled-radio" checked> Standard</label>
                                <label class="flex items-center text-sm"><input type="radio" name="channelMode" value="luminescence" class="w-4 h-4 mr-2 styled-radio"> Luminescence</label>
                                <label class="flex items-center text-sm"><input type="radio" name="channelMode" value="inverted" class="w-4 h-4 mr-2 styled-radio"> Inverted</label>
                                <label class="flex items-center text-sm"><input type="radio" name="channelMode" value="heatmap" class="w-4 h-4 mr-2 styled-radio"> Heatmap</label>
                                <label class="flex items-center text-sm"><input type="radio" name="channelMode" value="threshold" class="w-4 h-4 mr-2 styled-radio"> Threshold</label>
                            </div>
                            <div id="thresholdContainer" class="hidden mt-2">
                                <label for="thresholdSlider" class="text-sm font-semibold mb-1 block">Threshold: <span id="thresholdVal">30</span></label>
                                <input id="thresholdSlider" type="range" min="1" max="255" value="30" class="w-full h-2 bg-gray-200 dark:bg-gray-600 rounded-lg appearance-none cursor-pointer">
                            </div>
                        </div>
                        <div>
                            <label class="font-semibold mb-2 block">Sub-Analysis:</label>
                            <div class="grid grid-cols-2 gap-y-2 gap-x-4">
                                <label class="flex items-center text-sm"><input type="radio" name="subAnalysisMode" value="none" class="w-4 h-4 mr-2 styled-radio" checked> None</label>
                                <label class="flex items-center text-sm"><input type="radio" name="subAnalysisMode" value="q-curve" class="w-4 h-4 mr-2 styled-radio"> Q-Curve</label>
                                <label class="flex items-center text-sm"><input type="radio" name="subAnalysisMode" value="iterative" class="w-4 h-4 mr-2 styled-radio"> Iterative</label>
                                <label class="flex items-center text-sm"><input type="radio" name="subAnalysisMode" value="edge-analysis" class="w-4 h-4 mr-2 styled-radio"> Edge Analysis</label>
                                <label class="flex items-center text-sm"><input type="radio" name="subAnalysisMode" value="chroma-analysis" class="w-4 h-4 mr-2 styled-radio"> Chroma Analysis</label>
                            </div>
                        </div>
                    </div>
                    
                    <div class="space-y-4">
                        <div>
                            <label id="stitchLabel" class="font-semibold mb-2 block">Stitch Direction:</label>
                            <div class="flex space-x-2" id="stitchControls">
                                <input type="radio" id="stitchNone" name="stitchDirection" value="none" class="hidden" checked><label for="stitchNone" title="None" class="flex items-center justify-center bg-gray-200 dark:bg-gray-700 rounded-full w-8 h-8 cursor-pointer hover:bg-gray-300 dark:hover:bg-gray-600"><span class="font-bold text-gray-800 dark:text-gray-200">X</span></label>
                                <input type="radio" id="stitchLeft" name="stitchDirection" value="left" class="hidden"><label for="stitchLeft" title="Left" class="flex items-center justify-center bg-gray-200 dark:bg-gray-700 rounded-full w-8 h-8 cursor-pointer hover:bg-gray-300 dark:hover:bg-gray-600"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-800 dark:text-gray-200" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" /></svg></label>
                                <input type="radio" id="stitchTop" name="stitchDirection" value="top" class="hidden"><label for="stitchTop" title="Top" class="flex items-center justify-center bg-gray-200 dark:bg-gray-700 rounded-full w-8 h-8 cursor-pointer hover:bg-gray-300 dark:hover:bg-gray-600"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-800 dark:text-gray-200" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7" /></svg></label>
                                <input type="radio" id="stitchBottom" name="stitchDirection" value="bottom" class="hidden"><label for="stitchBottom" title="Bottom" class="flex items-center justify-center bg-gray-200 dark:bg-gray-700 rounded-full w-8 h-8 cursor-pointer hover:bg-gray-300 dark:hover:bg-gray-600"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-800 dark:text-gray-200" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7" /></svg></label>
                                <input type="radio" id="stitchRight" name="stitchDirection" value="right" class="hidden"><label for="stitchRight" title="Right" class="flex items-center justify-center bg-gray-200 dark:bg-gray-700 rounded-full w-8 h-8 cursor-pointer hover:bg-gray-300 dark:hover:bg-gray-600"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-800 dark:text-gray-200" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" /></svg></label>
                            </div>
                        </div>
                        <div class="flex items-center">
                            <input id="detailsCheck" type="checkbox" class="w-4 h-4 mr-2 styled-checkbox">
                            <label for="detailsCheck">Show details on photo?</label>
                        </div>
                    </div>
                </div>
            </div>
            
            <div id="singleFileButtons" class="flex flex-wrap justify-center gap-2">
                <button id="processBtn" class="bg-violet-600 hover:bg-violet-700 text-white font-bold py-2 px-4 md:px-6 rounded-full transition-colors">Process</button>
                <button id="gridBtn" class="bg-violet-600 hover:bg-violet-700 text-white font-bold py-2 px-4 md:px-6 rounded-full transition-colors">Grid Analysis</button>
                <button id="standardBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 dark:bg-gray-700 dark:hover:bg-gray-600 dark:text-gray-200 font-bold py-2 px-4 md:px-6 rounded-full transition-colors">STANDARD</button>
                <button id="saveBtn" class="bg-gray-200 hover:bg-gray-300 text-gray-800 dark:bg-gray-700 dark:hover:bg-gray-600 dark:text-gray-200 font-bold py-2 px-4 md:px-6 rounded-full transition-colors">Save Image</button>
            </div>

            <div id="batchButtons" class="hidden flex-col items-center justify-center space-y-4">
                <div class="flex flex-wrap justify-center gap-2">
                    <button id="batchProcessStandardBtn" class="bg-violet-600 hover:bg-violet-700 text-white font-bold py-2 px-4 md:px-6 rounded-full transition-colors">Process All (Standard)</button>
                    <button id="batchProcessGridBtn" class="bg-violet-600 hover:bg-violet-700 text-white font-bold py-2 px-4 md:px-6 rounded-full transition-colors">Process All (Grid)</button>
                </div>
                
                <div id="batchRangeContainer" class="w-full pt-4 mt-4 border-t border-gray-200 dark:border-gray-700">
                         <div class="flex flex-col items-center justify-center gap-2">
                             <div class="flex items-center gap-4">
                                 <label for="rangeStartInput">Process x from</label>
                                 <input type="number" id="rangeStartInput" value="5" class="bg-gray-200 dark:bg-gray-700 rounded-lg p-2 w-24 text-center">
                                 <label for="rangeEndInput">to</label>
                                 <input type="number" id="rangeEndInput" value="10" class="bg-gray-200 dark:bg-gray-700 rounded-lg p-2 w-24 text-center">
                             </div>
                             <button id="batchProcessRangeBtn" class="bg-teal-600 hover:bg-teal-700 text-white font-bold py-2 px-4 md:px-6 rounded-full transition-colors mt-2">Process IDA Range</button>
                           </div>
                </div>

                <div class="w-full pt-4 mt-4 border-t border-gray-200 dark:border-gray-700">
                    <div class="flex items-center justify-center">
                        <input id="advancedSettingsCheck" type="checkbox" class="w-4 h-4 mr-2 styled-checkbox">
                        <label for="advancedSettingsCheck" class="font-semibold">Show Advanced Output Settings</label>
                    </div>
                    <div id="advancedSettingsContainer" class="hidden mt-4 space-y-4">
                        <div class="p-4 bg-gray-50 dark:bg-gray-700/50 rounded-lg space-y-4">
                            <div>
                                <label for="namingPatternInput" class="font-semibold mb-2 block">File Naming Pattern:</label>
                                <input id="namingPatternInput" type="text" value="{fname}-{mode}-{channel}-{sub}" class="w-full bg-gray-200 dark:bg-gray-600 rounded-md p-2 text-sm">
                                <p class="text-xs text-gray-500 mt-1">Use: {fname}, {mode}, {channel}, {sub}, {m}, {x}</p>
                            </div>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 items-center">
                                <div>
                                    <label for="reduceSizeSlider" class="font-semibold mb-2 block">Reduce Size: <span id="reduceSizeVal" class="font-normal">50</span>%</label>
                                    <input id="reduceSizeSlider" type="range" min="10" max="100" value="50" class="w-full h-2 bg-gray-200 dark:bg-gray-600 rounded-lg appearance-none cursor-pointer">
                                </div>
                                <div>
                                    <label class="font-semibold mb-2 block">File Format:</label>
                                    <div class="flex space-x-4">
                                        <label class="flex items-center"><input type="radio" name="fileFormat" value="png" class="w-4 h-4 mr-2 styled-radio"> PNG</label>
                                        <label class="flex items-center"><input type="radio" name="fileFormat" value="jpg" class="w-4 h-4 mr-2 styled-radio" checked> JPG</label>
                                    </div>
                                </div>
                            </div>
                            <div id="jpgQualityContainer">
                                <label for="jpgQualitySlider" class="font-semibold mb-2 block">JPG Quality: <span id="jpgQualityVal" class="font-normal">80</span></label>
                                <input id="jpgQualitySlider" type="range" min="1" max="100" value="80" class="w-full h-2 bg-gray-200 dark:bg-gray-600 rounded-lg appearance-none cursor-pointer">
                            </div>
                            <div>
                                <label class="font-semibold mb-2 block">Download As:</label>
                                <div class="flex space-x-4">
                                    <label class="flex items-center"><input type="radio" name="downloadType" value="individual" class="w-4 h-4 mr-2 styled-radio" checked> Individual Files</label>
                                    <label class="flex items-center"><input type="radio" name="downloadType" value="zip" class="w-4 h-4 mr-2 styled-radio"> ZIP file</label>
                                </div>
                                <p id="zipWarning" class="text-xs text-yellow-600 dark:text-yellow-400 mt-2 hidden">Warning: Zipping large, un-reduced files may be slow.</p>
                            </div>
                        </div>
                    </div>
                </div>

                <button id="batchSaveBtn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 md:px-6 rounded-full transition-colors hidden">Save All Images</button>
            </div>
            
            <div id="processing-indicator" class="mt-4 text-center text-sm text-gray-600 dark:text-gray-400 min-h-[1.25rem]"></div>
            <div id="progressBarContainer" class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2.5 my-2 hidden">
                <div id="progressBar" class="bg-violet-600 h-2.5 rounded-full" style="width: 0%"></div>
            </div>

            <div id="canvas-container" class="relative mt-6">
                <canvas id="resultCanvas" class="w-full h-auto rounded-lg shadow-md"></canvas>
            </div>
        </div>
        
        <div id="documentationContainer" class="hidden prose dark:prose-invert max-w-none">
        </div>
    </div>

<script>
    // === CONFIG ===
    const DOCS_MARKDOWN_URL = 'readme.md';

    // === DOM Elements ===
    const analysisContainer = document.getElementById('analysisContainer');
    const documentationContainer = document.getElementById('documentationContainer');
    const singleFileView = document.getElementById('singleFileView');
    const batchView = document.getElementById('batchView');
    const singleFileButtons = document.getElementById('singleFileButtons');
    const batchButtons = document.getElementById('batchButtons');
    const dropAreaSingle = document.getElementById('drop-area-single');
    const dropAreaBatch = document.getElementById('drop-area-batch');
    const resultCanvas = document.getElementById('resultCanvas');
    const rCtx = resultCanvas.getContext('2d');
    const analysisTab = document.getElementById('analysisTab');
    const documentationTab = document.getElementById('documentationTab');
    const toggleViewBtn = document.getElementById('toggleViewBtn');
    const darkModeToggle = document.getElementById('darkModeToggle');
    const fileInput = document.getElementById('fileInput');
    const batchFileInput = document.getElementById('batchFileInput');
    const fileList = document.getElementById('fileList');
    const configList = document.getElementById('configList');
    const configNameInput = document.getElementById('configNameInput');
    const loadConfigBtn = document.getElementById('loadConfigBtn');
    const saveConfigBtn = document.getElementById('saveConfigBtn');
    const deleteConfigBtn = document.getElementById('deleteConfigBtn');
    const importConfigBtn = document.getElementById('importConfigBtn');
    const exportConfigBtn = document.getElementById('exportConfigBtn');
    const importConfigFileInput = document.getElementById('importConfigFileInput');
    const mInput = document.getElementById('mInput');
    const mContainer = document.getElementById('mContainer');
    const xInput = document.getElementById('xInput');
    const mVal = document.getElementById('mVal');
    const xVal = document.getElementById('xVal');
    const detailsCheck = document.getElementById('detailsCheck');
    const maxSizeInput = document.getElementById('maxSizeInput');
    const stitchLabel = document.getElementById('stitchLabel');
    const idaSpecificControls = document.getElementById('idaSpecificControls');
    const thresholdContainer = document.getElementById('thresholdContainer');
    const thresholdSlider = document.getElementById('thresholdSlider');
    const thresholdVal = document.getElementById('thresholdVal');
    const processBtn = document.getElementById('processBtn');
    const gridBtn = document.getElementById('gridBtn');
    const standardBtn = document.getElementById('standardBtn');
    const saveBtn = document.getElementById('saveBtn');
    const batchProcessStandardBtn = document.getElementById('batchProcessStandardBtn');
    const batchProcessGridBtn = document.getElementById('batchProcessGridBtn');
    const batchSaveBtn = document.getElementById('batchSaveBtn');
    const processingIndicator = document.getElementById('processing-indicator');
    const progressBarContainer = document.getElementById('progressBarContainer');
    const progressBar = document.getElementById('progressBar');
    const advancedSettingsCheck = document.getElementById('advancedSettingsCheck');
    const advancedSettingsContainer = document.getElementById('advancedSettingsContainer');
    const namingPatternInput = document.getElementById('namingPatternInput');
    const reduceSizeSlider = document.getElementById('reduceSizeSlider');
    const reduceSizeVal = document.getElementById('reduceSizeVal');
    const jpgQualityContainer = document.getElementById('jpgQualityContainer');
    const jpgQualitySlider = document.getElementById('jpgQualitySlider');
    const jpgQualityVal = document.getElementById('jpgQualityVal');
    const zipWarning = document.getElementById('zipWarning');
    // --- New Batch Range Elements ---
    const batchRangeContainer = document.getElementById('batchRangeContainer');
    const batchProcessRangeBtn = document.getElementById('batchProcessRangeBtn');
    const rangeStartInput = document.getElementById('rangeStartInput');
    const rangeEndInput = document.getElementById('rangeEndInput');


    // === App State ===
    let loadedFile = null;
    let loadedBatchFiles = [];
    let originalFileName = '';
    let batchCanvases = [];
    let savedConfigurations = {};
    let selectedProfileName = null;
    
    // === Event Listeners Setup ===
    function initializeEventListeners() {
        toggleViewBtn.addEventListener('click', toggleBatchMode);
        darkModeToggle.addEventListener('click', toggleDarkMode);
        analysisTab.addEventListener('click', () => switchTab('analysis'));
        documentationTab.addEventListener('click', () => switchTab('documentation'));
        saveConfigBtn.addEventListener('click', saveCurrentConfig);
        loadConfigBtn.addEventListener('click', loadSelectedConfig);
        deleteConfigBtn.addEventListener('click', deleteSelectedConfig);
        exportConfigBtn.addEventListener('click', exportConfigs);
        importConfigBtn.addEventListener('click', () => importConfigFileInput.click());
        importConfigFileInput.addEventListener('change', handleImportFile);
        configList.addEventListener('click', handleProfileSelection);
        fileInput.addEventListener('change', e => handleSingleFile(e.target.files[0]));
        setupDragDrop(dropAreaSingle, files => handleSingleFile(files[0]));
        batchFileInput.addEventListener('change', e => handleBatchFiles(e.target.files));
        setupDragDrop(dropAreaBatch, files => handleBatchFiles(files));
        mInput.addEventListener('input', () => { mVal.textContent = mInput.value; });
        xInput.addEventListener('input', () => { xVal.textContent = xInput.value; });
        thresholdSlider.addEventListener('input', () => { thresholdVal.textContent = thresholdSlider.value; });
        document.querySelectorAll('input[name="topLevelAnalysisMode"]').forEach(radio => radio.addEventListener('change', updateControlsBasedOnMode));
        document.querySelectorAll('input[name="channelMode"]').forEach(radio => radio.addEventListener('change', updateControlsBasedOnMode));
        document.querySelectorAll('input[name="subAnalysisMode"]').forEach(radio => radio.addEventListener('change', updateControlsBasedOnMode));
        processBtn.addEventListener('click', () => { if (loadedFile) processImageFile(loadedFile); });
        gridBtn.addEventListener('click', () => { if (loadedFile) processImageFile(loadedFile, true); });
        standardBtn.addEventListener('click', resetToStandardAndProcess);
        saveBtn.addEventListener('click', saveSingleResult);
        batchProcessStandardBtn.addEventListener('click', () => processBatch(false));
        batchProcessGridBtn.addEventListener('click', () => processBatch(true));
        batchSaveBtn.addEventListener('click', saveBatchResults);
        advancedSettingsCheck.addEventListener('change', () => advancedSettingsContainer.classList.toggle('hidden', !advancedSettingsCheck.checked));
        reduceSizeSlider.addEventListener('input', () => { reduceSizeVal.textContent = reduceSizeSlider.value; });
        jpgQualitySlider.addEventListener('input', () => { jpgQualityVal.textContent = jpgQualitySlider.value; });
        document.querySelectorAll('input[name="fileFormat"]').forEach(radio => { radio.addEventListener('change', (e) => jpgQualityContainer.classList.toggle('hidden', e.target.value !== 'jpg')); });
        document.querySelectorAll('input[name="downloadType"]').forEach(radio => { radio.addEventListener('change', (e) => { zipWarning.classList.toggle('hidden', e.target.value !== 'zip'); batchSaveBtn.textContent = e.target.value === 'zip' ? 'Save as ZIP' : 'Save All Individually'; }); });
        document.querySelectorAll('input, select').forEach(input => { input.addEventListener('change', saveCurrentUIToLocalStorage); });
        batchProcessRangeBtn.addEventListener('click', processBatchRange);
    }
    
    // === UI and State Management ===
    
    function switchTab(tabName) {
        const tabs = [
            { name: 'analysis', btn: analysisTab, container: analysisContainer },
            { name: 'documentation', btn: documentationTab, container: documentationContainer }
        ];

        tabs.forEach(tab => {
            const isActive = tab.name === tabName;
            tab.btn.classList.toggle('border-violet-500', isActive);
            tab.btn.classList.toggle('text-violet-600', isActive);
            tab.btn.classList.toggle('border-transparent', !isActive);
            tab.container.classList.toggle('hidden', !isActive);
        });

        if (tabName === 'documentation') {
            loadAndRenderMarkdown(documentationContainer, DOCS_MARKDOWN_URL);
        }
    }

    async function loadAndRenderMarkdown(container, url) {
        if (container.hasAttribute('data-loaded')) return;
        container.innerHTML = '<p>Loading content...</p>';
        try {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
            const markdownText = await response.text();
            container.innerHTML = marked.parse(markdownText);
            container.setAttribute('data-loaded', 'true');
        } catch (error) {
            console.error(`Failed to load markdown from ${url}:`, error);
            container.innerHTML = `<p class="text-red-500">Failed to load content. Please check the console for details.</p>`;
        }
    }
    function toggleBatchMode() { const isBatchMode = singleFileView.classList.toggle('hidden'); batchView.classList.toggle('hidden'); singleFileButtons.classList.toggle('hidden'); batchButtons.classList.toggle('hidden'); toggleViewBtn.textContent = isBatchMode ? 'Switch to Single Mode' : 'Switch to Batch Mode'; stitchLabel.textContent = isBatchMode ? 'Stitch Original to Grid:' : 'Stitch Direction:'; clearCanvas(); }
    function toggleDarkMode() { document.documentElement.classList.toggle('dark'); updateDarkModeIcon(); saveCurrentUIToLocalStorage(); }
    function updateDarkModeIcon() { const isDark = document.documentElement.classList.contains('dark'); document.getElementById('darkModeIcon').innerHTML = isDark ? `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.354 5.354l-.707.707M6.346 6.346l-.707-.707m12.728 0l-.707.707M6.346 17.654l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"></path>` : `<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"></path>`; }
    function updateControlsBasedOnMode() {
        const analysisMode = document.querySelector('input[name="topLevelAnalysisMode"]:checked').value;
        const channelMode = document.querySelector('input[name="channelMode"]:checked').value;
        const usesManualSliders = analysisMode === 'ida' || analysisMode === 'ela';
        const usesXSlider = analysisMode === 'ida';
        mContainer.classList.toggle('control-disabled', !usesManualSliders);
        mInput.disabled = !usesManualSliders;
        idaSpecificControls.classList.toggle('control-disabled', !usesXSlider);
        xInput.disabled = !usesXSlider;
        gridBtn.disabled = !usesXSlider;
        batchProcessGridBtn.disabled = !usesXSlider;
        batchRangeContainer.classList.toggle('control-disabled', !usesXSlider);
        thresholdContainer.classList.toggle('hidden', channelMode !== 'threshold');
    }
    function setProcessingState(isProcessing, message = 'Processing...') { const allButtons = document.querySelectorAll('button'); processingIndicator.textContent = isProcessing ? message : ''; allButtons.forEach(btn => { if(btn.id !== 'darkModeToggle') { btn.disabled = isProcessing; btn.classList.toggle('opacity-50', isProcessing); btn.classList.toggle('cursor-not-allowed', isProcessing); } }); if (!isProcessing) updateControlsBasedOnMode(); progressBarContainer.classList.toggle('hidden', !isProcessing || !batchView.classList.contains('hidden')); if (!isProcessing) progressBar.style.width = '0%'; }
    function setupDragDrop(area, callback) { area.addEventListener('dragover', e => { e.preventDefault(); area.classList.add('drag-over'); }); area.addEventListener('dragleave', () => area.classList.remove('drag-over')); area.addEventListener('drop', e => { e.preventDefault(); area.classList.remove('drag-over'); if (e.dataTransfer.files.length > 0) callback(e.dataTransfer.files); }); }
    async function handleSingleFile(file) { if (!file || !file.type.startsWith('image/')) return; loadedFile = file; originalFileName = file.name.split('.').slice(0, -1).join('.'); await processImageFile(loadedFile); }
    function handleBatchFiles(files) { if (!files || files.length === 0) return; loadedBatchFiles = Array.from(files).filter(f => f.type.startsWith('image/')); fileList.textContent = `${loadedBatchFiles.length} image(s) selected.`; batchSaveBtn.classList.add('hidden'); batchCanvases = []; clearCanvas(); }
    async function resetToStandardAndProcess() { if (!loadedFile) return; document.querySelector('input[name="topLevelAnalysisMode"][value="ida"]').checked = true; document.querySelector('input[name="channelMode"][value="standard"]').checked = true; document.querySelector('input[name="subAnalysisMode"][value="none"]').checked = true; mInput.value = 4; xInput.value = 5; mVal.textContent = 4; xVal.textContent = 5; updateControlsBasedOnMode(); await processImageFile(loadedFile); }

    // === Canvas and Image Utilities ===
    function clearCanvas() { rCtx.clearRect(0, 0, resultCanvas.width, resultCanvas.height); resultCanvas.width = 1; resultCanvas.height = 1; }
    function drawResult(canvasElem) { if (!canvasElem) return; resultCanvas.width = canvasElem.width; resultCanvas.height = canvasElem.height; rCtx.drawImage(canvasElem, 0, 0); }
    function loadImage(src) { return new Promise((resolve, reject) => { const img = new Image(); img.onload = () => resolve(img); img.onerror = reject; img.src = src; }); }
    function resizeImage(img, maxSize) { const { width, height } = img; if (Math.max(width, height) <= maxSize) return img; let newWidth, newHeight; if (width > height) { newWidth = maxSize; newHeight = (height / width) * maxSize; } else { newHeight = maxSize; newWidth = (width / height) * maxSize; } const canvas = document.createElement('canvas'); canvas.width = newWidth; canvas.height = newHeight; canvas.getContext('2d').drawImage(img, 0, 0, newWidth, newHeight); return canvas; }
    function clamp(val, min, max) { return Math.max(min, Math.min(max, val)); }
    function addDetailsText(ctx, text, x, y, width, height) { const padding = Math.min(width, height) * 0.02; const fontSize = Math.max(12, Math.min(width, height) * 0.03); ctx.font = `bold ${fontSize}px 'Courier New', Courier, monospace`; ctx.fillStyle = 'white'; ctx.lineWidth = 2; ctx.strokeStyle = 'black'; ctx.strokeText(text, x + padding, y + height - padding); ctx.fillText(text, x + padding, y + height - padding); }
    async function compressImage(img, quality) { const canvas = document.createElement('canvas'); canvas.width = img.width; canvas.height = img.height; canvas.getContext('2d').drawImage(img, 0, 0); const dataUrl = canvas.toDataURL('image/jpeg', quality / 100); return await loadImage(dataUrl); }

    // === Core Image Processing Logic ===

    // Corrected function from the old script
    function processAnalysisModes(oData, cData, dArr, w, h, params) {
        const { topLevelAnalysisMode, channelMode, m, x, threshold } = params;
        const sFactor = (topLevelAnalysisMode === 'ela') ? (7*25) : (m * (x * 5) * 47);
        
        let maxDiff = 0;
        for (let i = 0; i < oData.length; i += 4) {
            maxDiff = Math.max(maxDiff, Math.abs(oData[i] - cData[i]), Math.abs(oData[i + 1] - cData[i + 1]), Math.abs(oData[i + 2] - cData[i + 2]));
        }
        const scale = sFactor / (maxDiff || 1);

        for (let i = 0; i < oData.length; i += 4) {
            let r = Math.abs(oData[i] - cData[i]);
            let g = Math.abs(oData[i+1] - cData[i+1]);
            let b = Math.abs(oData[i+2] - cData[i+2]);
            
            switch(channelMode) {
                case 'standard': dArr[i] = clamp(r*scale,0,255); dArr[i+1]=clamp(g*scale,0,255); dArr[i+2]=clamp(b*scale,0,255); break;
                case 'luminescence': const lum=(r+g+b)/3; dArr[i]=dArr[i+1]=dArr[i+2]=clamp(lum*scale,0,255); break;
                case 'inverted': dArr[i]=255-clamp(r*scale,0,255); dArr[i+1]=255-clamp(g*scale,0,255); dArr[i+2]=255-clamp(b*scale,0,255); break;
                case 'heatmap': 
                    const intensity = clamp((r+g+b)/3*scale/255,0,1); 
                    dArr[i]=clamp(255*Math.sqrt(intensity),0,255); 
                    dArr[i+1]=clamp(255*(1-Math.abs(intensity-0.5)*2),0,255); 
                    dArr[i+2]=clamp(255*Math.sqrt(1-intensity),0,255); 
                    break;
                case 'threshold': const a=(r+g+b)/3; dArr[i]=dArr[i+1]=dArr[i+2]=(a>threshold?255:0); break;
            }
            dArr[i+3] = 255;
        }
    }
    
    // This is a helper for `getAnalysisCanvas`, now using the corrected `processAnalysisModes`
    function createDiffCanvas(img1, img2, params) {
        const w = img1.width, h = img1.height;
        const oCtx = document.createElement('canvas').getContext('2d'); oCtx.canvas.width = w; oCtx.canvas.height = h;
        oCtx.drawImage(img1, 0, 0);
        const oData = oCtx.getImageData(0, 0, w, h).data;
        const cCtx = document.createElement('canvas').getContext('2d'); cCtx.canvas.width = w; cCtx.canvas.height = h;
        cCtx.drawImage(img2, 0, 0);
        const cData = cCtx.getImageData(0, 0, w, h).data;
        const diffCanvas = document.createElement('canvas'); diffCanvas.width = w; diffCanvas.height = h;
        const dCtx = diffCanvas.getContext('2d');
        const diffData = dCtx.createImageData(w, h);
        
        // This is the key change: call the corrected function
        processAnalysisModes(oData, cData, diffData.data, w, h, params);
        
        dCtx.putImageData(diffData, 0, 0);
        return diffCanvas;
    }

    async function getAnalysisCanvas(origImg, params) {
        if (params.topLevelAnalysisMode === 'hybrid') return getHybridCanvas(origImg, params);
        if (params.topLevelAnalysisMode === 'double-exposure') return getDoubleExposureCanvas(origImg, params);
        if (params.subAnalysisMode === 'edge-analysis') return getEdgeAnalysisCanvas(origImg, params);
        if (params.subAnalysisMode === 'chroma-analysis') return getChromaAnalysisCanvas(origImg, params);
        if (params.subAnalysisMode === 'q-curve') return getQCurveCanvas(origImg, params);
        if (params.subAnalysisMode === 'iterative') return getIterativeCanvas(origImg, params);

        let secondImgForDiff;
        if (params.topLevelAnalysisMode === 'ela') {
            secondImgForDiff = await compressImage(origImg, 95);
        } else { // IDA - CORRECTED LOGIC
            // The original logic compressed to a quality of `x`, but capped at 10.
            // This was likely a mistake. The standard interpretation is that x is the quality.
            // Reverting to the old script's effective behavior: `x` IS the quality level for compression.
            const quality = parseInt(params.x); 
            secondImgForDiff = await compressImage(origImg, quality);
        }
        return createDiffCanvas(origImg, secondImgForDiff, params);
    }
    
    async function getHybridCanvas(origImg, params) { processingIndicator.textContent = 'Hybrid: Processing IDA pass (1/3)...'; const idaCanvas = await getAnalysisCanvas(origImg, { ...params, topLevelAnalysisMode: 'ida', subAnalysisMode: 'none', m: 1, x: 1 }); processingIndicator.textContent = 'Hybrid: Processing ELA pass (2/3)...'; const elaCanvas = await getAnalysisCanvas(origImg, { ...params, topLevelAnalysisMode: 'ela', subAnalysisMode: 'none' }); processingIndicator.textContent = 'Hybrid: Combining results (3/3)...'; const w = origImg.width, h = origImg.height; const idaData = idaCanvas.getContext('2d').getImageData(0, 0, w, h).data; const elaData = elaCanvas.getContext('2d').getImageData(0, 0, w, h).data; const finalCanvas = document.createElement('canvas'); finalCanvas.width = w; finalCanvas.height = h; const fCtx = finalCanvas.getContext('2d'); const fData = fCtx.createImageData(w, h); for (let i = 0; i < fData.data.length; i += 4) { const r = (elaData[i] === 0) ? 255 : clamp((idaData[i] / elaData[i]) * 255, 0, 255); const g = (elaData[i+1] === 0) ? 255 : clamp((idaData[i+1] / elaData[i+1]) * 255, 0, 255); const b = (elaData[i+2] === 0) ? 255 : clamp((idaData[i+2] / elaData[i+2]) * 255, 0, 255); fData.data[i] = r; fData.data[i+1] = g; fData.data[i+2] = b; fData.data[i+3] = 255; } fCtx.putImageData(fData, 0, 0); return finalCanvas; }
    async function getDoubleExposureCanvas(origImg, params) { processingIndicator.textContent = 'Double Exposure: Processing first pass (1/2)...'; const firstPassCanvas = await getAnalysisCanvas(origImg, { ...params, topLevelAnalysisMode: 'ida', subAnalysisMode: 'none', m: 1, x: 1 }); processingIndicator.textContent = 'Double Exposure: Processing second pass (2/2)...'; return await getAnalysisCanvas(firstPassCanvas, { ...params, topLevelAnalysisMode: 'ida', subAnalysisMode: 'none', m: 7, x: 6 }); }
    async function getQCurveCanvas(origImg, params) { const w = origImg.width, h = origImg.height; const qualities = (params.topLevelAnalysisMode === 'ela') ? [95, 85, 75] : [params.x, Math.max(1, params.x-10), Math.max(1, params.x-20)]; const diffs = await Promise.all([ getAnalysisCanvas(origImg, {...params, subAnalysisMode: 'none', x: qualities[0]}), getAnalysisCanvas(origImg, {...params, subAnalysisMode: 'none', x: qualities[1]}), getAnalysisCanvas(origImg, {...params, subAnalysisMode: 'none', x: qualities[2]}) ]); const datas = diffs.map(d => d.getContext('2d').getImageData(0,0,w,h).data); const finalCanvas = document.createElement('canvas'); finalCanvas.width = w; finalCanvas.height = h; const fCtx = finalCanvas.getContext('2d'); const fData = fCtx.createImageData(w,h); for(let i=0; i<fData.data.length; i+=4) { fData.data[i] = (datas[0][i] + datas[0][i+1] + datas[0][i+2])/3; fData.data[i+1] = (datas[1][i] + datas[1][i+1] + datas[1][i+2])/3; fData.data[i+2] = (datas[2][i] + datas[2][i+1] + datas[2][i+2])/3; fData.data[i+3] = 255; } fCtx.putImageData(fData,0,0); return finalCanvas; }
    async function getIterativeCanvas(origImg, params) { let qualities = []; if (params.topLevelAnalysisMode === 'ela') { qualities = [99, 95, 90, 85, 80]; } else { qualities = [80, 60, 50, 30, 20, 10, parseInt(params.x)]; } let currentImg = origImg; for (const quality of qualities) { currentImg = await compressImage(currentImg, quality); } return createDiffCanvas(origImg, currentImg, params); }
    async function getEdgeAnalysisCanvas(origImg, params) { processingIndicator.textContent = 'Edge Analysis: Detecting edges...'; const w = origImg.width, h = origImg.height; const oCtx = document.createElement('canvas').getContext('2d'); oCtx.canvas.width = w; oCtx.canvas.height = h; oCtx.drawImage(origImg, 0, 0); const oData = oCtx.getImageData(0, 0, w, h); const edgeData = oCtx.createImageData(w, h); for (let i = 0; i < oData.data.length; i += 4) { const avg = (oData.data[i] + oData.data[i+1] + oData.data[i+2]) / 3; oData.data[i] = oData.data[i+1] = oData.data[i+2] = avg; } for (let y = 1; y < h - 1; y++) { for (let x = 1; x < w - 1; x++) { const i = (y * w + x) * 4; const gx = -oData.data[i-4-w*4] - 2*oData.data[i-4] - oData.data[i-4+w*4] + oData.data[i+4-w*4] + 2*oData.data[i+4] + oData.data[i+4+w*4]; const gy = -oData.data[i-4-w*4] - 2*oData.data[i-w*4] - oData.data[i+4-w*4] + oData.data[i-4+w*4] + 2*oData.data[i+w*4] + oData.data[i+4+w*4]; const mag = Math.sqrt(gx*gx + gy*gy); edgeData.data[i] = edgeData.data[i+1] = edgeData.data[i+2] = mag; edgeData.data[i+3] = 255; } } const edgeCanvas = document.createElement('canvas'); edgeCanvas.width = w; edgeCanvas.height = h; edgeCanvas.getContext('2d').putImageData(edgeData, 0, 0); processingIndicator.textContent = 'Edge Analysis: Analyzing edges...'; return await getAnalysisCanvas(edgeCanvas, {...params, subAnalysisMode: 'none'}); }
    async function getChromaAnalysisCanvas(origImg, params) { processingIndicator.textContent = 'Chroma Analysis: Performing initial diff...'; const diffCanvas = await getAnalysisCanvas(origImg, {...params, subAnalysisMode: 'none'}); processingIndicator.textContent = 'Chroma Analysis: Isolating color channels...'; const w = diffCanvas.width, h = diffCanvas.height; const diffCtx = diffCanvas.getContext('2d'); const diffData = diffCtx.getImageData(0, 0, w, h); const chromaData = diffCtx.createImageData(w, h); for (let i = 0; i < diffData.data.length; i += 4) { const r = diffData.data[i]; const g = diffData.data[i+1]; const b = diffData.data[i+2]; const luma = (r + g + b) / 3; chromaData.data[i] = clamp(128 + r - luma, 0, 255); chromaData.data[i+1] = clamp(128 + g - luma, 0, 255); chromaData.data[i+2] = clamp(128 + b - luma, 0, 255); chromaData.data[i+3] = 255; } const finalCanvas = document.createElement('canvas'); finalCanvas.width = w; finalCanvas.height = h; finalCanvas.getContext('2d').putImageData(chromaData, 0, 0); return finalCanvas; }
    
    // CORRECTED function from the old script
    async function createGridCanvas(img, params) {
        const resultCanvases = [];
        // The original grid was a fixed 1-10 degradation sweep
        for (let x = 1; x <= 10; x++) {
            const gridParams = { ...params, x: x, stitchDirection: 'none', subAnalysisMode: 'none' };
            // We use getAnalysisCanvas to ensure it respects IDA mode
            const processedCanvas = await getAnalysisCanvas(img, gridParams);
            if (params.showDetails && params.topLevelAnalysisMode === 'ida') {
                addDetailsText(processedCanvas.getContext('2d'), `m=${params.m}, x=${x}`, 0, 0, processedCanvas.width, processedCanvas.height);
            }
            resultCanvases.push(processedCanvas);
        }
        const gridCanvas = document.createElement('canvas');
        gridCanvas.width = img.width * 5;
        gridCanvas.height = img.height * 2;
        const gridCtx = gridCanvas.getContext('2d');
        resultCanvases.forEach((canvas, i) => {
            const row = Math.floor(i / 5);
            const col = i % 5;
            gridCtx.drawImage(canvas, col * img.width, row * img.height);
        });
        return gridCanvas;
    }

    // --- Image Composition & Main Execution Flows ---
    function stitchImage(orig, diff, direction) { if (direction === 'none') return diff; const finalCanvas = document.createElement('canvas'); const fCtx = finalCanvas.getContext('2d'); const w = orig.width, h = orig.height; switch(direction) { case 'left': finalCanvas.width = w * 2; finalCanvas.height = h; fCtx.drawImage(diff, 0, 0); fCtx.drawImage(orig, w, 0); break; case 'right': finalCanvas.width = w * 2; finalCanvas.height = h; fCtx.drawImage(orig, 0, 0); fCtx.drawImage(diff, w, 0); break; case 'top': finalCanvas.width = w; finalCanvas.height = h * 2; fCtx.drawImage(diff, 0, 0); fCtx.drawImage(orig, 0, h); break; case 'bottom': finalCanvas.width = w; finalCanvas.height = h * 2; fCtx.drawImage(orig, 0, 0); fCtx.drawImage(diff, 0, h); break; } return finalCanvas; }
    async function processSingleImageCore(img, params) { const analysisCanvas = await getAnalysisCanvas(img, params); if(params.showDetails && params.stitchDirection === 'none' && params.topLevelAnalysisMode === 'ida') { addDetailsText(analysisCanvas.getContext('2d'), `m=${params.m}, x=${params.x}`, 0, 0, analysisCanvas.width, analysisCanvas.height); } return stitchImage(img, analysisCanvas, params.stitchDirection); }
    function stitchGridWithOriginal(originalImage, gridCanvas, direction) { if (direction === 'none') return gridCanvas; const resizeToMatch = (imgToResize, refCanvas, dim) => { const canvas = document.createElement('canvas'); const aspectRatio = imgToResize.width / imgToResize.height; let newW, newH; if (dim === 'height') { newH = refCanvas.height; newW = newH * aspectRatio; } else { newW = refCanvas.width; newH = newW / aspectRatio; } canvas.width = newW; canvas.height = newH; canvas.getContext('2d').drawImage(imgToResize, 0, 0, newW, newH); return canvas; }; const resizedOriginal = resizeToMatch(originalImage, gridCanvas, (direction === 'left' || direction === 'right') ? 'height' : 'width'); const finalCanvas = document.createElement('canvas'); const fCtx = finalCanvas.getContext('2d'); if (direction === 'left' || direction === 'right') { finalCanvas.width = gridCanvas.width + resizedOriginal.width; finalCanvas.height = gridCanvas.height; if (direction === 'left') { fCtx.drawImage(resizedOriginal, 0, 0); fCtx.drawImage(gridCanvas, resizedOriginal.width, 0); } else { fCtx.drawImage(gridCanvas, 0, 0); fCtx.drawImage(resizedOriginal, gridCanvas.width, 0); } } else { finalCanvas.width = gridCanvas.width; finalCanvas.height = gridCanvas.height + resizedOriginal.height; if (direction === 'top') { fCtx.drawImage(resizedOriginal, 0, 0); fCtx.drawImage(gridCanvas, 0, resizedOriginal.height); } else { fCtx.drawImage(gridCanvas, 0, 0); fCtx.drawImage(resizedOriginal, 0, gridCanvas.height); } } return finalCanvas; }
    async function processImageFile(file, isGrid = false) { if (!file) return; setProcessingState(true, isGrid ? 'Creating Grid...' : 'Processing...'); await new Promise(r => setTimeout(r, 50)); const img = await loadImage(URL.createObjectURL(file)); const params = collectCurrentSettings(); let finalCanvas; if (isGrid) { const gridCanvas = await createGridCanvas(img, params); finalCanvas = stitchGridWithOriginal(img, gridCanvas, params.stitchDirection); } else { finalCanvas = await processSingleImageCore(img, params); } drawResult(finalCanvas); setProcessingState(false); }
    async function processBatch(isGrid) { if (loadedBatchFiles.length === 0) return; setProcessingState(true, 'Starting batch process...'); batchCanvases = []; batchSaveBtn.classList.add('hidden'); progressBar.style.width = '0%'; const maxSize = parseInt(maxSizeInput.value) || 1000; for (let i = 0; i < loadedBatchFiles.length; i++) { const file = loadedBatchFiles[i]; const progress = ((i + 1) / loadedBatchFiles.length) * 100; setProcessingState(true, `Processing ${i + 1}/${loadedBatchFiles.length}: ${file.name}`); progressBar.style.width = `${progress}%`; await new Promise(r => setTimeout(r, 20)); const originalImage = await loadImage(URL.createObjectURL(file)); const resizedImage = resizeImage(originalImage, maxSize); const params = collectCurrentSettings(); let finalCanvas; if (isGrid) { const gridCanvas = await createGridCanvas(resizedImage, params); finalCanvas = stitchGridWithOriginal(resizedImage, gridCanvas, params.stitchDirection); } else { finalCanvas = await processSingleImageCore(resizedImage, params); } const fname = file.name.split('.').slice(0, -1).join('.'); batchCanvases.push({ name: fname, canvas: finalCanvas, params: params, isGrid: isGrid }); drawResult(finalCanvas); } setProcessingState(false, 'Batch processing complete.'); processingIndicator.textContent = `${batchCanvases.length} images processed and ready to save.`; if (batchCanvases.length > 0) batchSaveBtn.classList.remove('hidden'); }
    async function processBatchRange() { if (loadedBatchFiles.length === 0) { alert('Please select one or more images for batch processing.'); return; } const start = parseInt(rangeStartInput.value); const end = parseInt(rangeEndInput.value); if (isNaN(start) || isNaN(end) || start > end || start < 1 || end > 100) { alert('Please enter a valid range (1-100), with start <= end.'); return; } setProcessingState(true, 'Starting batch range process...'); batchCanvases = []; batchSaveBtn.classList.add('hidden'); progressBar.style.width = '0%'; const maxSize = parseInt(maxSizeInput.value) || 1000; const xValues = Array.from({length: end - start + 1}, (_, i) => start + i); const totalJobs = loadedBatchFiles.length * xValues.length; let jobsDone = 0; for (const file of loadedBatchFiles) { const originalImage = await loadImage(URL.createObjectURL(file)); const resizedImage = resizeImage(originalImage, maxSize); const fname = file.name.split('.').slice(0, -1).join('.'); for (const x of xValues) { jobsDone++; const progress = (jobsDone / totalJobs) * 100; setProcessingState(true, `Processing ${jobsDone}/${totalJobs}: ${fname} at x=${x}`); progressBar.style.width = `${progress}%`; await new Promise(r => setTimeout(r, 10)); const params = { ...collectCurrentSettings(), x: x, stitchDirection: 'none' }; const finalCanvas = await processSingleImageCore(resizedImage, params); batchCanvases.push({ name: `${fname}_x${x}`, canvas: finalCanvas, params: params, isGrid: false }); } } setProcessingState(false, 'Batch range processing complete.'); processingIndicator.textContent = `${batchCanvases.length} images processed and ready to save.`; if (batchCanvases.length > 0) batchSaveBtn.classList.remove('hidden'); }

    // === Saving, Downloading, and Settings Profile Logic (Unchanged) ===
    function saveSingleResult() { if (!loadedFile) return; const dataURL = resultCanvas.toDataURL('image/png'); downloadDataURL(dataURL, `${originalFileName}_Forensics.png`); }
    async function saveBatchResults() { if (!batchCanvases || batchCanvases.length === 0) return; setProcessingState(true, 'Preparing downloads...'); const useAdvanced = advancedSettingsCheck.checked; const sizeReduction = useAdvanced ? parseInt(reduceSizeSlider.value) / 100 : 1.0; const format = useAdvanced ? document.querySelector('input[name="fileFormat"]:checked').value : 'jpg'; const quality = useAdvanced ? parseInt(jpgQualitySlider.value) / 100 : 0.8; const downloadType = useAdvanced ? document.querySelector('input[name="downloadType"]:checked').value : 'individual'; const mimeType = `image/${format === 'jpg' ? 'jpeg' : 'png'}`; const getFinalFileName = (item) => { if (!useAdvanced) return `${item.name}.${format}`; let pattern = namingPatternInput.value; return pattern.replace('{fname}', item.name).replace('{mode}', item.params.topLevelAnalysisMode).replace('{channel}', item.params.channelMode).replace('{sub}', item.params.subAnalysisMode).replace(/{m}|{factor}/g, item.params.m).replace(/{x}|{degradation}/g, item.params.x).replace(/-{sub}/, item.params.subAnalysisMode === 'none' ? '' : `-${item.params.subAnalysisMode}`) + `.${format}`; }; const getOutputFile = (item) => { return new Promise(resolve => { const sourceCanvas = item.canvas; const tempCanvas = document.createElement('canvas'); tempCanvas.width = sourceCanvas.width * sizeReduction; tempCanvas.height = sourceCanvas.height * sizeReduction; tempCanvas.getContext('2d').drawImage(sourceCanvas, 0, 0, tempCanvas.width, tempCanvas.height); if (downloadType === 'zip') { tempCanvas.toBlob(resolve, mimeType, quality); } else { resolve(tempCanvas.toDataURL(mimeType, quality)); } }); }; if (downloadType === 'zip') { const zip = new JSZip(); for (let i = 0; i < batchCanvases.length; i++) { const item = batchCanvases[i]; const finalName = getFinalFileName(item); setProcessingState(true, `Zipping ${i + 1}/${batchCanvases.length}: ${finalName}`); const blob = await getOutputFile(item); zip.file(finalName, blob); } setProcessingState(true, 'Generating ZIP file...'); const content = await zip.generateAsync({ type: "blob", compression: "STORE" }); downloadBlob(content, 'ImageForensics_Batch_Results.zip'); } else { for (let i = 0; i < batchCanvases.length; i++) { const item = batchCanvases[i]; const finalName = getFinalFileName(item); setProcessingState(true, `Downloading ${i + 1}/${batchCanvases.length}: ${finalName}`); const dataURL = await getOutputFile(item); downloadDataURL(dataURL, finalName); await new Promise(resolve => setTimeout(resolve, 250)); } } setProcessingState(false); processingIndicator.textContent = `Finished downloading ${batchCanvases.length} files.`; batchCanvases = []; }
    function downloadDataURL(dataURL, filename) { const link = document.createElement('a'); link.href = dataURL; link.download = filename; document.body.appendChild(link); link.click(); document.body.removeChild(link); }
    function downloadBlob(blob, filename) { const link = document.createElement('a'); link.href = URL.createObjectURL(blob); link.download = filename; document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(link.href); }
    function collectCurrentSettings() { return { topLevelAnalysisMode: document.querySelector('input[name="topLevelAnalysisMode"]:checked').value, m: mInput.value, x: xInput.value, channelMode: document.querySelector('input[name="channelMode"]:checked').value, subAnalysisMode: document.querySelector('input[name="subAnalysisMode"]:checked').value, stitchDirection: document.querySelector('input[name="stitchDirection"]:checked').value, showDetails: detailsCheck.checked, maxSize: maxSizeInput.value, threshold: thresholdSlider.value, advanced: advancedSettingsCheck.checked, namingPattern: namingPatternInput.value, reduceSize: reduceSizeSlider.value, format: document.querySelector('input[name="fileFormat"]:checked').value, quality: jpgQualitySlider.value, downloadType: document.querySelector('input[name="downloadType"]:checked').value, darkMode: document.documentElement.classList.contains('dark'), }; }
    function applySettings(settings) { if (!settings) return; document.querySelector(`input[name="topLevelAnalysisMode"][value="${settings.topLevelAnalysisMode || 'ida'}"]`).checked = true; mInput.value = settings.m; mVal.textContent = settings.m; xInput.value = settings.x; xVal.textContent = settings.x; document.querySelector(`input[name="channelMode"][value="${settings.channelMode || 'standard'}"]`).checked = true; document.querySelector(`input[name="subAnalysisMode"][value="${settings.subAnalysisMode || 'none'}"]`).checked = true; document.querySelector(`input[name="stitchDirection"][value="${settings.stitchDirection}"]`).checked = true; detailsCheck.checked = settings.showDetails; maxSizeInput.value = settings.maxSize; thresholdSlider.value = settings.threshold || 30; thresholdVal.textContent = settings.threshold || 30; advancedSettingsCheck.checked = settings.advanced; namingPatternInput.value = settings.namingPattern; reduceSizeSlider.value = settings.reduceSize; reduceSizeVal.textContent = settings.reduceSize; document.querySelector(`input[name="fileFormat"][value="${settings.format}"]`).checked = true; jpgQualitySlider.value = settings.quality; jpgQualityVal.textContent = settings.quality; document.querySelector(`input[name="downloadType"][value="${settings.downloadType}"]`).checked = true; if (settings.darkMode) document.documentElement.classList.add('dark'); else document.documentElement.classList.remove('dark'); updateDarkModeIcon(); updateControlsBasedOnMode(); advancedSettingsContainer.classList.toggle('hidden', !settings.advanced); jpgQualityContainer.classList.toggle('hidden', settings.format !== 'jpg'); zipWarning.classList.toggle('hidden', settings.downloadType !== 'zip'); batchSaveBtn.textContent = settings.downloadType === 'zip' ? 'Save as ZIP' : 'Save All Individually'; }
    function saveCurrentUIToLocalStorage() { try { localStorage.setItem('forensicsToolSettings', JSON.stringify(collectCurrentSettings())); } catch (e) { console.error("Could not save settings.", e); } }
    function loadLastUIFromLocalStorage() { try { applySettings(JSON.parse(localStorage.getItem('forensicsToolSettings'))); } catch (e) { console.error("Could not load settings.", e); localStorage.removeItem('forensicsToolSettings'); } }
    function populateConfigList() { configList.innerHTML = ''; const hasProfiles = Object.keys(savedConfigurations).length > 0; if (!hasProfiles) { const placeholder = document.createElement('div'); placeholder.textContent = 'No profiles saved.'; placeholder.className = 'text-center text-gray-500 italic p-4'; configList.appendChild(placeholder); } else { for (const name in savedConfigurations) { const item = document.createElement('div'); item.textContent = name; item.dataset.name = name; item.className = 'p-2 rounded-md cursor-pointer hover:bg-violet-200 dark:hover:bg-violet-800 transition-colors'; if (name === selectedProfileName) { item.classList.add('bg-violet-300', 'dark:bg-violet-700', 'font-semibold'); } configList.appendChild(item); } } loadConfigBtn.disabled = !selectedProfileName; deleteConfigBtn.disabled = !selectedProfileName; exportConfigBtn.disabled = !hasProfiles; }
    function handleProfileSelection(event) { const target = event.target.closest('[data-name]'); if (target) { const name = target.dataset.name; selectedProfileName = (selectedProfileName === name) ? null : name; populateConfigList(); } }
    function saveConfigsToLocalStorage() { localStorage.setItem('forensicsToolProfiles', JSON.stringify(savedConfigurations)); }
    function loadConfigsFromLocalStorage() { try { const profilesJSON = localStorage.getItem('forensicsToolProfiles'); if (profilesJSON) savedConfigurations = JSON.parse(profilesJSON); } catch(e) { console.error("Could not load profiles", e); savedConfigurations = {}; } }
    function saveCurrentConfig() { const name = configNameInput.value.trim(); if (!name) { alert('Please enter a name for this profile.'); return; } savedConfigurations[name] = collectCurrentSettings(); selectedProfileName = name; saveConfigsToLocalStorage(); populateConfigList(); configNameInput.value = ''; }
    function loadSelectedConfig() { if (!selectedProfileName || !savedConfigurations[selectedProfileName]) { alert('Please select a profile to load.'); return; } applySettings(savedConfigurations[selectedProfileName]); saveCurrentUIToLocalStorage(); }
    function deleteSelectedConfig() { if (!selectedProfileName || !savedConfigurations[selectedProfileName]) { alert('Please select a profile to delete.'); return; } if (confirm(`Are you sure you want to delete the profile "${selectedProfileName}"?`)) { delete savedConfigurations[selectedProfileName]; selectedProfileName = null; saveConfigsToLocalStorage(); populateConfigList(); } }
    function exportConfigs() { if (Object.keys(savedConfigurations).length === 0) { alert('No profiles to export.'); return; } const jsonString = JSON.stringify(savedConfigurations, null, 2); const blob = new Blob([jsonString], { type: 'application/json' }); downloadBlob(blob, 'forensics-profiles.json'); }
    function handleImportFile(event) { const file = event.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = (e) => { try { const importedConfigs = JSON.parse(e.target.result); if (typeof importedConfigs !== 'object' || importedConfigs === null) throw new Error('Invalid file format.'); if (confirm('Merge imported profiles with existing ones? (Cancel to replace)')) { Object.assign(savedConfigurations, importedConfigs); } else { savedConfigurations = importedConfigs; } selectedProfileName = null; saveConfigsToLocalStorage(); populateConfigList(); alert('Profiles imported successfully!'); } catch (error) { alert(`Error importing file: ${error.message}`); } }; reader.readAsText(file); importConfigFileInput.value = ''; }
    
    // --- App Initialization ---
    document.addEventListener('DOMContentLoaded', () => {
        loadLastUIFromLocalStorage();
        loadConfigsFromLocalStorage();
        populateConfigList();
        initializeEventListeners();
    });
    
</script>
</body>
</html>
